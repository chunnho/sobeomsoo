'use client';
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useRef, useState } from 'react';
import useElementScroll from '../hooks/useElementScroll';
import useElementSize from '../hooks/useElementSize';
import useHash from '../hooks/useHash';
import useSwipe from '../hooks/useSwipe';
import FullpageContents from './FullpageContents';
import FullpageScrollbar from './FullpageScrollbar';
function FullpageSection(_a) {
    var children = _a.children, allowScroll = _a.allowScroll, allowScrollUp = _a.allowScrollUp, allowScrollDown = _a.allowScrollDown, _b = _a.isAutoHeight, isAutoHeight = _b === void 0 ? false : _b, activeIndex = _a.activeIndex, sectionCount = _a.sectionCount, _c = _a.isAnimating, isAnimating = _c === void 0 ? false : _c, setActiveIndex = _a.setActiveIndex, setIsAnimating = _a.setIsAnimating, _d = _a.name, name = _d === void 0 ? '' : _d, _e = _a.index, index = _e === void 0 ? 0 : _e, topScrollOnChange = _a.topScrollOnChange, transitionDuration = _a.transitionDuration;
    var sectionRef = useRef(null);
    var contentsRef = useRef(null);
    var contentsHeight = useElementSize(contentsRef).height;
    var _f = useElementScroll(sectionRef, contentsHeight), isAtTop = _f.isAtTop, isAtBottom = _f.isAtBottom, hasScrollbar = _f.hasScrollbar, scrollY = _f.scrollY;
    var _g = useState(false), scrollDelay = _g[0], setScrollDelay = _g[1];
    var hashValue = useHash().hashValue;
    var deltaWeightTimer = useRef(0);
    var _h = useState(0), deltaWeight = _h[0], setDeltaWeight = _h[1]; // wheel 가중치
    var _j = useState(0), lastDeltaWeight = _j[0], setLastDeltaWeight = _j[1];
    // wheel 속도가 마지막 wheel 속도보다 빠르면 true 또는 wheel이벤트가 300ms 이상 없으면 true
    var wheelTokenTimer = useRef(null);
    var wheelToken = useRef(true);
    useEffect(function () {
        if (hashValue) {
            if (hashValue === name) {
                if (setActiveIndex !== undefined) {
                    setActiveIndex(index);
                }
                // updateHash();
            }
        }
    }, [hashValue, setActiveIndex, index, name]);
    useEffect(function () {
        setScrollDelay(isAtTop || isAtBottom);
    }, [isAtTop, isAtBottom]);
    useEffect(function () {
        if (scrollDelay) {
            var timer_1 = setTimeout(function () {
                setScrollDelay(false);
            }, 300);
            return function () { return clearTimeout(timer_1); };
        }
    }, [scrollDelay]);
    var moveToSection = function (newIndex) {
        if (setIsAnimating === undefined || setActiveIndex === undefined)
            return; // 타입 에러 회피용
        if (!allowScroll || isAnimating || scrollDelay)
            return;
        setIsAnimating(true);
        setActiveIndex(newIndex);
    };
    var moveToNextSection = function () {
        if (activeIndex === undefined ||
            sectionCount === undefined ||
            activeIndex >= sectionCount - 1 ||
            !allowScrollDown)
            return;
        if (activeIndex === index) {
            if (hasScrollbar && !isAtBottom)
                return;
        }
        moveToSection(activeIndex + 1);
    };
    var moveToPrevSection = function () {
        if (activeIndex === undefined || activeIndex <= 0 || !allowScrollUp)
            return;
        if (activeIndex === index) {
            if (hasScrollbar && !isAtTop)
                return;
        }
        moveToSection(activeIndex - 1);
    };
    var handelWheel = function (e) {
        var t = new Date().getTime();
        if (t - deltaWeightTimer.current < 300) {
            var computed = deltaWeight + Math.abs(e.deltaY);
            if (computed > lastDeltaWeight) {
                // wheel의 속도가 lastDeltaWeight보다 높으면 token 초기화
                wheelToken.current = true;
            }
            setDeltaWeight(computed);
        }
        else {
            setLastDeltaWeight(deltaWeight);
            deltaWeightTimer.current = t;
            setDeltaWeight(0);
        }
        // token이 false라면 스크립트 중지
        if (!wheelToken.current)
            return;
        if (e.deltaY > 0) {
            moveToNextSection();
        }
        if (e.deltaY < 0) {
            moveToPrevSection();
        }
    };
    useEffect(function () {
        wheelToken.current = false;
        if (wheelTokenTimer.current !== null) {
            clearTimeout(wheelTokenTimer.current);
        }
        wheelTokenTimer.current = setTimeout(function () {
            // wheel이벤트가 300ms동안 발생하지 않으면 token 초기화
            wheelToken.current = true;
            setDeltaWeight(0);
        }, 300);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [deltaWeight]);
    var handleSwipeEnd = function (direction) {
        if (direction === 'UP') {
            moveToNextSection();
        }
        if (direction === 'DOWN') {
            moveToPrevSection();
        }
    };
    useSwipe(sectionRef, {
        onSwipeEnd: handleSwipeEnd,
    });
    useEffect(function () {
        if (topScrollOnChange) {
            if (activeIndex !== index) {
                setTimeout(function () {
                    var _a;
                    (_a = sectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo(0, 0);
                }, transitionDuration);
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [activeIndex]);
    return (_jsxs("div", { ref: sectionRef, onWheel: handelWheel, className: "react-fullpage__section", "data-active": activeIndex === index, "data-animating": isAnimating, style: {
            height: "".concat(isAutoHeight ? 'auto' : '100%'),
        }, children: [_jsx(FullpageContents, { contentsRef: contentsRef, children: children }), hasScrollbar && !isAnimating && (_jsx(FullpageScrollbar, { contentsHeight: contentsHeight, scrollY: scrollY, sectionRef: sectionRef }))] }));
}
export default FullpageSection;
//# sourceMappingURL=FullpageSection.js.map